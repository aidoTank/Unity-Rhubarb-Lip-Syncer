using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using UnityEditor;
using UnityEngine;

public class LipSyncer : MonoBehaviour
{
    [Tooltip("This object should have an Animator element and all animated objects should be its children.")]
    public GameObject parentObject;
    [Tooltip("Objects to be animated for mouth shapes")]
    public GameObject[] mouthObjects;
    [Tooltip("Should we add randomized blinks?")]
    public bool animateBlinks;
    [Tooltip("Objects to be animated for a blink")]
    public GameObject[] blinkObjects;
    [Tooltip("Should we add randomized eyebrow movements?")]
    public bool animateEyebrows;
    [Tooltip("Objects to be animated for eyebrow movement")]
    public GameObject[] eyebrowObjects;
    [Tooltip("Dialog audio clip")]
    public AudioClip sourceAudio;
    [Tooltip("Optional transcription of the audio file. Providing this will result in more accurate animation.")]
    public TextAsset sourceAudioScript;
    [Tooltip("Generated by Rhubarb by pressing button 1")]
    public TextAsset phenomeList;
    [Tooltip("The name for the resulting animation. Saved to Assets/Animations/Resources/")]
    public string animationName;

    [Tooltip("Minimum time in seconds between blinks")]
    public float blinkMin;
    [Tooltip("Minimum time in seconds between blinks")]
    public float blinkMax;
    [Tooltip("Duration of a blink in seconds")]
    public float blinkLength;
    string outputAssetNameAddition = " - Mouth Shapes";

    List<string> mouthShape = new List<string>() { "A", "B", "C", "D", "E", "F", "G", "H", "X" };
    List<string> eyebrowShape = new List<string>() { "Angry", "Sad", "Raised" };
    public List<Keyframe>[] mouthKeyframe;

    AnimationClip resultAnimation;
    int currentIndex = -1, lastIndex = -1;
    
    // Start is called before the first frame update
    void Start()
    {
        phenomeList = Resources.Load(sourceAudio.name + outputAssetNameAddition) as TextAsset;
    }

    bool CheckForErrors(int operation)
    {
        bool error = false;

        if (parentObject == null)
        {
            UnityEngine.Debug.LogError("Parent Object is required!");
            error = true;
        }
        if (mouthObjects.Length == 0)
        {
            UnityEngine.Debug.LogError("At least one Mouth Object is required!");
            error = true;
        }
        if (operation == 0 && sourceAudio == null)
        {
            UnityEngine.Debug.LogError("Source Audio is required!");
            error = true;
        }
        if (animationName == null || animationName.Trim().Equals(""))
        {
            UnityEngine.Debug.LogError("Animation Name is required!");
            error = true;
        }
        if (operation == 1 && phenomeList == null)
        {
            UnityEngine.Debug.LogError("Source Text is required!");
            error = true;
        }

        return error;
    }

    public void RhubarbAnalysis()
    {
        if (CheckForErrors(0))
            return;

        phenomeList = null;
        string dataPath = Application.dataPath;
        string audioPath = AssetDatabase.GetAssetPath(sourceAudio);
        string outputFile = audioPath.Substring(0, audioPath.LastIndexOf(".")) + outputAssetNameAddition + ".txt";
        string args = "/c cd ../ && echo \"Generating phenome list from audio. Window will close when finished.\" && rhubarb -o \"" + outputFile + "\" \"" + audioPath + "\"";
        if (sourceAudioScript != null)
            args += " -d \"" + AssetDatabase.GetAssetPath(sourceAudioScript) + "\"";

        print(args);

        ProcessStartInfo info = new ProcessStartInfo()
            {
                WorkingDirectory = dataPath,
                FileName = "cmd.exe",
                Arguments = args,
                WindowStyle = ProcessWindowStyle.Normal
            };
        Process p = Process.Start(info);

        while (!p.HasExited) { }

        StartCoroutine(FindPhenomeFile(sourceAudio.name + outputAssetNameAddition));
    }

    IEnumerator FindPhenomeFile(string filename)
    {
        while (phenomeList == null)
        {
            phenomeList = Resources.Load(filename) as TextAsset;
            yield return new WaitForSecondsRealtime(0.1f);
        }
        GenerateAnimation();
    }

    public void GenerateAnimation()
    {
        if (CheckForErrors(1))
            return;

        resultAnimation = new AnimationClip { };

        mouthKeyframe = new List<Keyframe>[mouthShape.Count];
        for (int i = 0; i < mouthKeyframe.Length; i++)
        {
            mouthKeyframe[i] = new List<Keyframe>
            {
                new Keyframe(0f, 0f)
            };
        }

        string[] mouthLines = phenomeList.text.Split('\n');

        foreach (string s in mouthLines)
        {
            if (!s.Trim().Equals(""))
            {
                string[] param = s.Split('\t');
                currentIndex = mouthShape.FindIndex(param[1].Contains);
                if (!s.Trim().Equals("X")) {
                    mouthKeyframe[currentIndex].Add(new Keyframe(float.Parse(param[0]) - .25f, 0f));
                    mouthKeyframe[currentIndex].Add(new Keyframe(float.Parse(param[0]), 60f));
                }
                if (lastIndex != -1)
                    mouthKeyframe[lastIndex].Add(new Keyframe(float.Parse(param[0]), 0f));
                lastIndex = currentIndex;
            }
        }

        AssetDatabase.CreateAsset(resultAnimation, "Assets/Animations/Resources/" + animationName + ".anim");

        /*
        This code is specific to how I'm adding the animations in my game.
        It's not necessary for creating the animation and can break things if your game is not set up the same way.
        I'm leaving it commented out in case you're curious how I'm using them for some reason.
         
        AudioSource audioSource = parentObject.GetComponent<AudioSource>();
        if (audioSource == null)
        {
            audioSource = (AudioSource)parentObject.AddComponent(typeof(AudioSource));
            audioSource.playOnAwake = false;
        }
        audioSource.clip = sourceAudio;

        AnimatorOverrideController charOverride = Resources.Load(parentObject.name + "_Override") as AnimatorOverrideController;

        Animator anim = parentObject.GetComponent<Animator>();
        if (anim == null)
        {
            anim = (Animator)parentObject.AddComponent(typeof(Animator));
        }

        if (charOverride == null)
        {
            charOverride = new AnimatorOverrideController(Resources.Load("Character_Override") as AnimatorOverrideController);
            charOverride["Face Idle"] = Resources.Load(parentObject + "_Idle") as AnimationClip;
            anim.runtimeAnimatorController = charOverride;

            AssetDatabase.CreateAsset(charOverride, "Assets/Animations/Resources/" + parentObject.name + "_Override.overrideController");
        }
        */

        // Add mouth shape curves
        AnimationCurve curve;
        for (int i = 0; i < mouthKeyframe.Length - 1; i++)
        {
            curve = new AnimationCurve(mouthKeyframe[i].ToArray());
            foreach (GameObject o in mouthObjects)
            {
                resultAnimation.SetCurve(RelativePath(o), typeof(SkinnedMeshRenderer), "blendShape." + mouthShape[i], curve);
            }
        }

        float eyeTimer = 0f;

        // Add blink curve
        if (animateBlinks)
        {
            List<Keyframe> blinkFrames = new List<Keyframe>();
            while (eyeTimer < resultAnimation.length - blinkMax)
            {
                eyeTimer += Random.Range(blinkMin, blinkMax);
                blinkFrames.Add(new Keyframe(eyeTimer - blinkLength / 2, 0));
                blinkFrames.Add(new Keyframe(eyeTimer, 100));
                blinkFrames.Add(new Keyframe(eyeTimer + blinkLength / 2, 0));
            }
            curve = new AnimationCurve(blinkFrames.ToArray());
            foreach (GameObject o in blinkObjects)
            {
                resultAnimation.SetCurve(RelativePath(o), typeof(SkinnedMeshRenderer), "blendShape.Blink", curve);
            }
        }

        // Add eyebrow curve
        if (animateEyebrows)
        {
            List<Keyframe>[] eyebrowFrames = new List<Keyframe>[3];
            for (int i = 0; i < eyebrowFrames.Length; i++)
                eyebrowFrames[i] = new List<Keyframe>();
            eyeTimer = 0f;
            lastIndex = -1;
            while (eyeTimer < resultAnimation.length - blinkMax)
            {
                eyeTimer += Random.Range(blinkMin / 1.5f, blinkMax);
                currentIndex = Random.Range(0, eyebrowShape.Count);
                float hold = Random.Range(.2f, .8f);
                float blendValue = Random.Range(10, 40);
                MaybeAddKeyframe(eyebrowFrames[currentIndex], new Keyframe(eyeTimer - Random.Range(.2f, .5f), 0), .5f);
                MaybeAddKeyframe(eyebrowFrames[currentIndex], new Keyframe(eyeTimer, blendValue), .5f);
                MaybeAddKeyframe(eyebrowFrames[currentIndex], new Keyframe(eyeTimer + hold, blendValue + Random.Range(10, 10)), .5f);
                MaybeAddKeyframe(eyebrowFrames[currentIndex], new Keyframe(eyeTimer + hold + Random.Range(.2f, .5f), 0), .5f);

                lastIndex = currentIndex;
            }
            for (int i = 0; i < eyebrowFrames.Length; i++)
            {
                curve = new AnimationCurve(eyebrowFrames[i].ToArray());
                foreach (GameObject o in eyebrowObjects)
                {
                    resultAnimation.SetCurve(RelativePath(o), typeof(SkinnedMeshRenderer), "blendShape.Eyebrows " + eyebrowShape[i], curve);
                }
            }
        }

        AssetDatabase.SaveAssets();
    }

    public void MaybeAddKeyframe(List<Keyframe> frames, Keyframe key, float chance)
    {
        if (Random.Range(0, 1) <= chance)
        {
            frames.Add(key);
        }
    }

    public string RelativePath(GameObject o)
    {
        string relativePath = o.name;
        Transform levelUp = o.transform;
        while (levelUp = levelUp.parent)
        {
            if (levelUp == null)
            {
                UnityEngine.Debug.LogError("All animated objects must be children of the parent object!");
            }
            else
            {
                if (levelUp != parentObject.transform)
                {
                    relativePath = levelUp.name + "/" + relativePath;
                }
            }
        }

        return relativePath;
    }

    // Update is called once per frame
    void Update()
    {
    }
}